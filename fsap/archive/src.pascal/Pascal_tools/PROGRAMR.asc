
     PROGNOTE                                              update 10/21/90
                              PROGRAMMERS' NOTES

     A. GENERAL CONSIDERATIONS
          I have put a lot of thought into making this package as portable as 
     possible.  Towards this end, I have avoided using large sets, extended 
     comparisons between variables of the same structured type, dependancy on 
     ASCII values returned by the ord function, and other features allowed by 
     Standard Pascal but which may differ from compiler to compiler. I have 
     probably not thought of all of them. Probably the only statements which 
     will need to be changed will be those relevant to file I/O. All of these 
     non-standard or unusual constructs are denoted in the source code of the 
     programs by three exclamation points appearing within a comment, 
     beginning in the leftmost column of a given line. Since each version of 
     Pascal has slightly different ways of handling file I/O, it is up to you 
     to get it to work on your particular system.  These programs have so far 
     been implemented in a number of programming environments, including 
     Apple UCSD Pascal, Apple Macintosh, IBM-PC DOS Pascal (Microsoft), IBM/370 
     CMS (Pascal 8000 and Pascal/VS), Unix Pascal, BASIS, and others. 

     B. TRANSPORTATION STRATEGY
     
     1. Compile and Test FSAPMODS.
     To facilitate transportation, subroutines, constant and type declarations,
     and other pieces of code which are used in more than one program have been
     collected together in the program FSAPMODS.  These pieces of code are
     referred to as "modules", and can be inserted into the other programs 
     using the MODULE program. To be precise, the programs are distributed
     as 'raw' programs, in which each module is represented as an empty module.
     Thus MODULE actually REPLACES modules in a given program with the
     corresponding modules in FSAPMODS.  (Read MODDEF for a more complete 
     description, or Schneider, Stormo, Yarus, & Gold, Nucl.Acids Res.12
     p129-140 (1984).) The most important consequence of modularization is that
     if you can get FSAPMODS to compile and run, then the modules can be 
     inserted into the other programs, rather than having to change the code
     by hand in each program.  Thus, the first step is to get FSAPMODS to 
     compile and run. The program contains code for testing of interactive I/O.

     
     2. Compile and Test MODULE
     Read MODDEF for a thorough description of module replacement. The syntax    
     for MODULE is

     MODULE RAW MODLIB SOUT MODCAT LIST OUTPUT

     where

     RAW is the the file for which dummy modules are to be replaced with 
     modules from MODLIB. Raw files should have the file extension .rp

     MODLIB is the version of FSAPMODS appropriate for your particular Pascal
     compiler. 

     SOUT is the file to store the final source code, which should be ready
     to compile. This file should have the file extension .p

     MODCAT is a catalog of MODLIB for use by MODULE. The first time MODULE
     is run, it is necessary to creat a MODCAT file containing a couple of 
     blank lines. When MODULE begins, it checks to see whether MODCAT is 
     consistent with MODLIB. If it is not, MODULE will rewrite MODCAT to 
     reflect the current state of MODLIB. Thus, when you make changes in
     MODLIB, MODULE automatically revises MODCAT to reflect these changes.

     LIST is a file to which a listing will be written, describing which
     modules were replaced in RAW.


     OUTPUT is usually the standard file output. User messages are written 
     to this file.

     Pascal compilers such as SUN Pascal, which do not allow file substitution
     in the command line, require that the files used by MODULE actually have
     the names 'raw', 'modlib', 'sout' etc. The UNIX shell script create 
     automatically takes care of this.

     Pascal compilers such as Microsoft Pascal for DOS do allow file
     substitution in the command line. Thus, to produce compileable source
     code for funnel, type

     MODULE FUNNEL.RP DOSMODS.P FUNNEL.P DOSMODS.CAT FUNNEL.LST 

     (OUTPUT is not needed).

     3. Convert the Remaining Programs
        a. Modify the raw program.  Among things to consider are:
           - have all characters been properly translated by the new machine?
           - compiler options for turning off errorchecking during execution
             (Runtime errorchecking code generated by most compilers takes
             up memory and is not necessary for these programs.) 
           - MAXSEQ and other constants may need to be changed
           - some Pascals may require file parameters in program headings
        b. Replace modules in raw program using MODULE.
        c. Compile the source program.
        d. Test the compiled program.
        e. (optional) Once you have compiled code, you may wish to strip
           the modules from the source file to re-create a smaller raw file.
           The "dummy" module lines found in FSAPMODS can be used to create
           a dummy library called FSAPMODR.  You will also need to create a
           new dummy MODCAT file the first time you do this.

     In most cases, module replacement and compilation can be done automatic-
     ally. In UNIX, the shell script create.csh will automatically perform 
     module replacement, while compile.csh will compile the programs. (See
     UNIX.doc for more information.) Versions of create and compile also exist
     as MS-DOS batch files (See DOS.doc).
          
     C. REQUIREMENTS OF SPECIFIC PASCAL COMPILERS
     1. Apple Pascal
     NOTE: Apple UCSD Pascal is no longer supported. The February 1986 version
     of the FSAP programs is still available from Brian Fristensky.

     The Apple Pascal reset and rewrite statements take the following form:

     reset(<filename>,<string>)
     rewrite(<filename>,<string>)

     where<filename> is a variable of the type text, which is declared in the 
     program heading, and <string> is a variable of the type STRING, which 
     refers to a particular file listed in a disk directory.  Thus the 
     <filename>s INFILE and OUTFILE, which are declared in the program 
     heading, are used internally by the program to refer to input and output 
     files during I/O, and the reset and rewrite statements associate these 
     internal filenames with external (ie. system dependant) filenames, held 
     by the STRING variable FILENAME in the procedure GETFILE. Some 
     programs require other input files. Each program must close the files
     it uses with the non-standard CLOSE statement, which takes the follow-
     ing form: 

     CLOSE(<filename>[,LOCK])

     where <filename> is the internal name of a file, as described above.
     The word LOCK, preceeded by a comma, must appear for all files 
     which are to be written permanently to a disk.
     In Apple Pascal, the "vertical arrow" character, used with pointer 
     types, is represented by the character "^". 

     Some of the longer programs, such as INTREST, BACHREST and LINEPLOT 
     may require the swapping compiler option (*$S+*) in order to compile on 
     an AppleII.  Additionally, it may be necessary, when editing these 
     programs, to set swapping on while in the command mode, before entering 
     the editor. This slows down the editor, but allows larger files to be 
     edited. 

     2. Microsoft (IBM) Pascal
     For the non-programmer, the only things peculiar to the IBM version 
     of the package are DOS filenaming conventions.  These can be found 
     in the DOS operating system manual.  Essentially any legal DOS 
     filename can be used for input or output, but you should probably 
     give them descriptive suffixes, such as .DNA or .PRO. To send 
     output to the printer, use PRN or LPT1 as the output filename.  To 
     send output to the screen use USER.  Examples can be found in 
     program documentation. The first problem with IBM Pascal is that, 
     if file identifiers other than input and output appear in the 
     program statement, the compiler automatically generates code to ask 
     the user for filenames.  To circumvent this, the other filenames 
     are put in comments. To open an input file, two statements are 
     required: 

           ASSIGN(<filename>,<string>);
           reset(<filename>); 

          Similarly, to open an output file:

           ASSIGN(<filename>,<string>);
           rewrite(<filename>);

           All character I/O to textfiles is done by the "lazy I/O" approach, 
     in which the statement read(P) is equivalent to:  

           get(F);  P:= F^;
          
           The file pointer always points to the last character read, 
     even in real or integer I/O.  Some of the input routines have had to be 
     modified to accomodate this type of I/O, and the current versions will 
     now work in both Standard I/O and lazy I/O. 
           More peculiarities of IBM Pascal:  IBM Pascal uses VALUE as a 
     reserved word.  Since VALUE was also used as a variable identifier in 
     the original version of the package in the procedure INRANGE in the 
     program LINEPLOT, this has been changed to V in the current version.
     WORD and MAXWORD are predefined identifiers in IBM Pascal, but may be 
     redefined by the user.  I have allowed them to remain unchanged in this 
     version.  Also, the identifier ORIGIN in the program MAP was not 
     permitted in the const section.  I have no idea why this is, but have 
     changed it to ORI in the IBM version.  

  3. Pascal 8000
     When Pascal reset's a textfile, it sets the file pointer to the value of 
     the first character in the file.  For disk files, this presents no 
     problem, provided the file is accessable.  However, the standard file 
     input, which is predeclared in Pascal, is automatically reset when the 
     program begins execution.  If input refers to the keyboard (which is 
     usually the case for interactive programs), then the first action of the 
     program would be to wait for a character to be typed at the keyboard, 
     even before a prompting message could be printed.  Pascal 8000 gets 
     around this problem by allowing files to be designated as interactive, 
     by appending the slash character (/) to the filename in the program 
     heading.  Thus, 

     program INTREST(input/, output, INFILE, OUTFILE)
     declares input to be an interactive file.  When program execution 
     begins, input@ is undefined, and eoln is true.  Pascal 8000 waits until 
     a return character is typed at the keyboard before attempting to read.  
     To read the first line typed by the user, and all subsequent lines 
     typed, a readln statement must preceed each read.  Consequently, all 
     interactive input must take the form 

     readln;read(<arguments>) .

     After the read statement is executed, eoln is once again true. Pascal 
     8000 requires all output files which are to be written to disk to be 
     closed using the close statement: 

     CLOSE(<filename>) .

     In Pascal 8000, the "vertical arrow" character, used with pointer types, 
     is represented by the character "@". 

   3.UNIX Pascal compilers
     The FSAP programs originally under the ATT Pascal compiler for the ATT 3b2
     workstations. These have now been ported to SUN Pascal, and it is the
     SUN Pascal version of UNIXMODS that is distributed with the programs.
     Two changes were required to convert the ATT programs to work on SUN. Most
     important was the need to write a procedure called 'exists', which is
     used in GETFILE to determine whether a file exists prior to opening it.
     This procedure is present as an extension to ATT Pascal, so ATT users
     simply need to comment out exists or remove it from unixmods.p. Also, 
     SUN Pascal doesn't use the CLOSE procedure, so this was commented out
     in ALL of the programs. It may not actually be necessary to use CLOSE
     under the ATT compiler, but I have not had the opportunity to port the
     programs back to System V to find out. When compiling with SUN Pascal, it
     is also necessary to use the -L option, which makes the compiler case 
     insensitive when reading the source code.  Finally, the programs are 
     distributed to UNIX users with a 32-bit architecture in mind, meaning
     that constants like MAXSEQ are set to large values (eg. 150000) which
     exceed the maximum allowable size for integers on 16-bit machines like
     PC's.  

     D. CHARACTER INTERPRETATION
     Those planning to use these programs on an IBM mainframe should be aware 
     that IBM mainframes represent their characters in EBCDIC rather than 
     ASCII. Thus, some characters may not be interpreted correctly.  Of 
     particular note are square bracket characters [ and ], and the vertical 
     arrow ^. Before trying to compile on your IBM system, check the Pascal 
     code of one of the programs to see if there are "unusual" characters 
     where they shouldn't be.  If there are any substitutions, you can easily 
     change them using a text editor.  Consult your computer center for 
     information regarding your particular system. 

     E. PROGRAMMING STYLE
     These programs can be most easily understood by other programmers by
     observing the following points about the programming style I have used.
     A.  Standard Pascal reserved words are in lowercase letters.
         Other identifiers are in capitals or mixed case.
     B.  Sub-procedures of the main procedure are set off by boxes formed by
         comment lines.  These boxes describe the tasks performed by the
         procedures.
     C.  goto has been avoided, with the exceptions being in INTREST 
         and BACHREST, in which alternative constructs would have been less 
         efficient or elegant.  Some implementations of Pascal may require 
         some sort of (*$G+*) compiler option to permit goto. 
     D.  In Pascal, the semicolon (;) is a statement separator, not a
         statement terminator, and I have followed this convention.  Should 
         you wish to modify these programs, make sure that you include 
         semicolons where necessary. 
