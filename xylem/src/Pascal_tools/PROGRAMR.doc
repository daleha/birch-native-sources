
     PROGNOTE                                              update  8/ 8/93
                              PROGRAMMERS' NOTES

     A. GENERAL CONSIDERATIONS
          I have put a lot of thought into making this package as portable as 
     possible.  Towards this end, I have avoided using large sets, extended 
     comparisons between variables of the same structured type, dependancy on 
     ASCII values returned by the ord function, and other features allowed by 
     Standard Pascal but which may differ from compiler to compiler. I have 
     probably not thought of all of them. Probably the only statements which 
     will need to be changed will be those relevant to file I/O. All of these 
     non-standard or unusual constructs are denoted in the source code of the 
     programs by three exclamation points appearing within a comment, 
     beginning in the leftmost column of a given line. Since each version of 
     Pascal has slightly different ways of handling file I/O, it is up to you 
     to get it to work on your particular system.   

     B. TRANSPORTATION STRATEGY
    
     1. Compile and Test MODLIB.
     To facilitate transportation, subroutines, constant and type declarations,
     and other pieces of code which are used in more than one program have been
     collected together in the program MODLIB.  These pieces of code are
     referred to as "modules", and can be inserted into the other programs 
     using the MODULE program. To be precise, the programs are distributed
     as 'raw' programs, in which each module is represented as an empty module.
     Thus MODULE actually REPLACES modules in a given program with the
     corresponding modules in MODLIB.  (Read MODULE.doc for a more complete 
     description, or Schneider, Stormo, Yarus, & Gold, Nucl.Acids Res.12
     p129-140 (1984).) The most important consequence of modularization is that
     if you can get MODLIB to compile and run, then the modules can be 
     inserted into the other programs, rather than having to change the code
     by hand in each program.  Thus, the first step is to get MODLIB to 
     compile and run. The program contains code for testing of interactive I/O.

     NOTE: 1)THE MODLIB PROGRAM IS PROVIDED IN TWO VERSIONS: DOSMODS.P FOR 
     MS-DOS, AND xylem/src/pascal_tools/sunmods.p FOR UNIX.
     2) XYLEM does not use the procedure GETFILE. If that is the only thing
     keeping sunmods.p from compiling, you can delete it. 
     
     Once you are satisfied with modlib, copy it into the 'install'
     directory under the name 'modlib'. 

     2. Compile and Test MODULE
     Read MODDEF for a thorough description of module replacement. 
   
     In most cases, module replacement and compilation can be done automatic-
     ally. In UNIX, the shell script create.csh will automatically perform 
     module replacement, while compile.csh will compile the programs. (See
     comments in compile.csh for more information.)

     The syntax for MODULE is

     module raw modlib sout modcat list output

     where

     RAW is the the file for which existing modules are to be replaced with 
     modules from MODLIB. Raw files should have the file extension .rp or
     .p.

     MODLIB is the version of MODLIB appropriate for your particular Pascal
     compiler. 

     SOUT is the file to store the final source code, which should be ready
     to compile. This file should have the file extension .p

     MODCAT is a catalog of MODLIB for use by MODULE. The first time MODULE
     is run, it is necessary to creat a MODCAT file containing a couple of 
     blank lines. When MODULE begins, it checks to see whether MODCAT is 
     consistent with MODLIB. If it is not, MODULE will rewrite MODCAT to 
     reflect the current state of MODLIB. Thus, when you make changes in
     MODLIB, MODULE automatically revises MODCAT to reflect these changes.

     LIST is a file to which a listing will be written, describing which
     modules were replaced in RAW.


     OUTPUT is usually the standard file output. User messages are written 
     to this file.

     Pascal compilers such as SUN Pascal, which do not allow file substitution
     in the command line, require that the files used by MODULE actually have
     the names 'raw', 'modlib', 'sout' etc. The UNIX shell script create 
     automatically takes care of this.

     3. Convert the Remaining Programs
        a. Modify the raw program.  Among things to consider are:
           - have all characters been properly translated by the new machine?
           - compiler options for turning off errorchecking during execution
             (Runtime errorchecking code generated by most compilers takes
             up memory and is not necessary for these programs.) 
           - MAXSEQ and other constants may need to be changed
           - some Pascals may require file parameters in program headings
        
        b. Replace modules in raw program using MODULE.
          
         eg. from within the xylem directory: 

           cd src
           foreach file (*.p)
           ?set name = $file:r
           ?cp $name.p ../install/$name.rp
           ?end
           cd ../install
           create.csh

        c. Compile the source program.

           compile.csh

        d. Test the compiled program.

           cd ../../test
           testxylem.csh

        e. (optional) Once you have compiled code, you may wish to strip
           the modules from the source file to re-create a smaller raw file.
           The "dummy" module lines found in MODLIB can be used to create
           a dummy library called MODLIBR.  You will also need to create a
           new dummy MODCAT file the first time you do this.

          
     C. REQUIREMENTS OF SPECIFIC PASCAL COMPILERS

     1. Microsoft (IBM) Pascal
     For the non-programmer, the only things peculiar to the IBM version 
     of the package are DOS filenaming conventions.  These can be found 
     in the DOS operating system manual.  Essentially any legal DOS 
     filename can be used for input or output, but you should probably 
     give them descriptive suffixes, such as .DNA or .PRO. To send 
     output to the printer, use PRN or LPT1 as the output filename.  To 
     send output to the screen use USER.  Examples can be found in 
     program documentation. The first problem with IBM Pascal is that, 
     if file identifiers other than input and output appear in the 
     program statement, the compiler automatically generates code to ask 
     the user for filenames.  To circumvent this, the other filenames 
     are put in comments. To open an input file, two statements are 
     required: 

           ASSIGN(<filename>,<string>);
           reset(<filename>); 

          Similarly, to open an output file:

           ASSIGN(<filename>,<string>);
           rewrite(<filename>);

           All character I/O to textfiles is done by the "lazy I/O" approach, 
     in which the statement read(P) is equivalent to:  

           get(F);  P:= F^;
          
           The file pointer always points to the last character read, 
     even in real or integer I/O.  Some of the input routines have had to be 
     modified to accomodate this type of I/O, and the current versions will 
     now work in both Standard I/O and lazy I/O. 
           More peculiarities of IBM Pascal:  IBM Pascal uses VALUE as a 
     reserved word.  Since VALUE was also used as a variable identifier in 
     the original version of the package in the procedure INRANGE in the 
     program LINEPLOT, this has been changed to V in the current version.
     WORD and MAXWORD are predefined identifiers in IBM Pascal, but may be 
     redefined by the user.  I have allowed them to remain unchanged in this 
     version.  Also, the identifier ORIGIN in the program MAP was not 
     permitted in the const section.  I have no idea why this is, but have 
     changed it to ORI in the IBM version.  

  2. Pascal 8000
     When Pascal reset's a textfile, it sets the file pointer to the value of 
     the first character in the file.  For disk files, this presents no 
     problem, provided the file is accessable.  However, the standard file 
     input, which is predeclared in Pascal, is automatically reset when the 
     program begins execution.  If input refers to the keyboard (which is 
     usually the case for interactive programs), then the first action of the 
     program would be to wait for a character to be typed at the keyboard, 
     even before a prompting message could be printed.  Pascal 8000 gets 
     around this problem by allowing files to be designated as interactive, 
     by appending the slash character (/) to the filename in the program 
     heading.  Thus, 

     program INTREST(input/, output, INFILE, OUTFILE)
     declares input to be an interactive file.  When program execution 
     begins, input@ is undefined, and eoln is true.  Pascal 8000 waits until 
     a return character is typed at the keyboard before attempting to read.  
     To read the first line typed by the user, and all subsequent lines 
     typed, a readln statement must preceed each read.  Consequently, all 
     interactive input must take the form 

     readln;read(<arguments>) .

     After the read statement is executed, eoln is once again true. Pascal 
     8000 requires all output files which are to be written to disk to be 
     closed using the close statement: 

     CLOSE(<filename>) .

     In Pascal 8000, the "vertical arrow" character, used with pointer types, 
     is represented by the character "@". 

   3.UNIX Pascal compilers
     The XYLEM programs were originally written using the ATT Pascal compiler
     for the ATT 3b2
     workstations. These have now been ported to SUN Pascal, and it is the
     SUN Pascal version of UNIXMODS that is distributed with the programs.
     Two changes were required to convert the ATT programs to work on SUN. Most
     important was the need to write a procedure called 'exists', which is
     used in GETFILE to determine whether a file exists prior to opening it.
     This procedure is present as an extension to ATT Pascal, so ATT users
     simply need to comment out exists or remove it from unixmods.p. Also, 
     SUN Pascal doesn't use the CLOSE procedure, so this was commented out
     in ALL of the programs. It may not actually be necessary to use CLOSE
     under the ATT compiler, but I have not had the opportunity to port the
     programs back to System V to find out. When compiling with SUN Pascal, it
     is also necessary to use the -L option, which makes the compiler case 
     insensitive when reading the source code.  Finally, the programs are 
     distributed to UNIX users with a 32-bit architecture in mind, meaning
     that constants like MAXSEQ are set to large values (eg. 150000) which
     exceed the maximum allowable size for integers on 16-bit machines like
     PC's.  

     D. CHARACTER INTERPRETATION
     Those planning to use these programs on an IBM mainframe should be aware 
     that IBM mainframes represent their characters in EBCDIC rather than 
     ASCII. Thus, some characters may not be interpreted correctly.  Of 
     particular note are square bracket characters [ and ], and the vertical 
     arrow ^. Before trying to compile on your IBM system, check the Pascal 
     code of one of the programs to see if there are "unusual" characters 
     where they shouldn't be.  If there are any substitutions, you can easily 
     change them using a text editor.  Consult your computer center for 
     information regarding your particular system. 

     E. PROGRAMMING STYLE
     These programs can be most easily understood by other programmers by
     observing the following points about the programming style I have used.
     A.  Standard Pascal reserved words are in lowercase letters.
         Other identifiers are in capitals or mixed case.
     B.  Sub-procedures of the main procedure are set off by boxes formed by
         comment lines.  These boxes describe the tasks performed by the
         procedures.
     C.  In Pascal, the semicolon (;) is a statement separator, not a
         statement terminator, and I have followed this convention.  Should 
         you wish to modify these programs, make sure that you include 
         semicolons where necessary. 
